<template lang="pug">
.field(:data-name="name" data-type="select" :data-layout="layout" :data-size="size" :class="classes" :title="title")
    FormFieldLabel(v-if="label && isLabelVisible" :text="label" :secondary-text="secondaryLabel")
    template(v-if="slots.input")
        //- custom input slot means using NDropdown instead of NSelect
        NDropdown(
            trigger="click"
            :options="dropdownOptions"
            v-bind="dropdownProps"
            v-on:select="handleDropdownSelect"
            v-on:update:show="handleUpdateShow"
        )
            slot(name="input")
    template(v-else)
        //- normal select component
        NSelect(
            ref="select"
            v-model:value="value"
            :options="selectOptions"
            v-bind="selectProps"
            v-on:search="handleSearch"
            v-on:focus="handleFocus"
            v-on:blur="handleBlur"
            v-on:update:show="handleUpdateShow"
            v-on:click="handleClick"
            v-on:clear="handleClear"
            v-on:keydown="(event: KeyboardEvent) => { handleKeydown(event) }"
            v-on:create="createCustomValueOption"
        )
            template(v-slot:empty)
                span.no-options(:class="{ 'loading': props.loading }")
                    span.text {{ getBlankValueLabelText() }}
            template(v-slot:arrow)
                slot(v-if="slots.arrow" name="arrow")
                SvgImage(v-else name="chevron-down")
            template(v-if="slots.action" v-slot:action)
                slot(name="action")
    .description(v-if="slots.description")
        slot(name="description")
    FormErrors(:errors="errors")
</template>
<script setup lang="ts">
import { NSelect, NDropdown } from "naive-ui"; // explicit import needed for typescript during build
import { SvgImage } from "#components";

type OptionIconObject = { name: string, alt?: string };

export type SelectOption = {
    value: string | number,
    label: string,
    disabled?: boolean,
    icon?: string | null | OptionIconObject,
};

// layout and size options and logic are the same as for text fields. see FormInputField component for comments

const props = withDefaults(defineProps<{
    name?: string,
    modelValue?: string | number | null, // for some reason NaiveUI expects model value to also support number type
    customValue?: string | null,
    label?: string,
    labelVisible?: boolean,
    secondaryLabel?: string,
    options: SelectOption[],
    layout?: "loose" | "compact",
    size?: "medium" | "large",
    menuWidth?: "fixed" | "auto",
    filterable?: boolean,
    filter?: (pattern: string, option: object) => boolean,
    remote?: boolean,
    clearable?: boolean,
    placeholder?: string,
    disabled?: boolean,
    changed?: boolean,
    loading?: boolean,
    show?: boolean | undefined,
    errors?: FormFieldError[],
}>(), {
    labelVisible: true,
    layout: "loose",
    size: "medium",
    menuWidth: "auto",
    filterable: false,
    remote: false,
    clearable: true,
    placeholder: "",
    disabled: false,
    changed: false,
    loading: false,
    show: undefined
});

const slots = useSlots();

const select = useTemplateRef("select");

const customValueAllowed = computed(() => props.customValue !== undefined);

// if entering a custom value is allowed, then the custom options generated by NaiveUI need some new custom values (fake IDs),
// that would not clash with the actual values of the other options.
// so add a prefix for those values internally.
// this custom prefix is never exposed outside of the component
// because values get cleaned up before being emitted.
// NaiveUI does not provide cleaner ways of differentiating custom values from actual option values.
const CUSTOM_OPTION_VALUE_PREFIX = "<<<CUSTOM-VALUE>>>:";

const buildCustomValue = (value: string) => {
    return CUSTOM_OPTION_VALUE_PREFIX + value;
};

const isCustomValue = (value: string | number | null): boolean => {
    return typeof value === "string" && value.startsWith(CUSTOM_OPTION_VALUE_PREFIX);
};

const extractCustomValueText = (value: string): string => {
    if (!isCustomValue(value)) {
        return value;
    }
    return value.slice(CUSTOM_OPTION_VALUE_PREFIX.length);
};

// this value is the main model that is connected to v-model.
// the NSelect interacts only directly with this value model,
// but if entering custom values is allowed, then internally the main value model getter and setter
// will handle where the value should come from and go to, as the component supports two separate models for that scenario
// (main model for values coming from actual options, and secondary model for storing the entered custom text)
const value = computed({
    get: () => {
        if (customValueAllowed.value && customValue.value !== null) {
            return customValue.value;
        }
        return props.modelValue;
    },
    set: (value: string | number | null) => {
        // NOTE: the order of emitting model values is important here.
        // customValue should always get set first, so that it emits the update before the main model value,
        // as outside code relies on this order (e.g., in Location field)
        if (typeof value === "string" && isCustomValue(value)) {
            // if the value is from a custom option, then emit that as a string on the custom value model,
            // and emit the main value as null
            customValue.value = value;
            emit("update:modelValue", null);
            emit("change");
        } else {
            // otherwise emit the main value normally and emit custom value as null
            customValue.value = null;
            emit("update:modelValue", value);
            emit("change");
        }
    }
});

// this computed prop is connected to v-model:custom-value
const customValue = computed({
    get: () => {
        if (!customValueAllowed.value || props.customValue === undefined) {
            return undefined;
        }
        if (props.customValue === null) {
            return null;
        }
        // the custom prefix needs to be prepended so that the value matches the value of the generated custom option
        return buildCustomValue(props.customValue);
    },
    set: (value: string | null) => {
        if (typeof value === "string") {
            value = extractCustomValueText(value);
        }
        emit("update:customValue", value);
    }
});

const createCustomValueOption = (customText: string) => {
    // this is used both for creating a new custom option as the user is typing,
    // and also to show the already stored custom value in the field (called "fallback option" in NaiveUI),
    // so the customText argument may receive the custom text with the prefix already included,
    // and we need to prevent the prefixes from stacking up and extract the actual text first.
    const extractedText = extractCustomValueText(customText);
    return {
        value: buildCustomValue(extractedText),
        label: extractedText
    };
};


const classes = computed(() => {
    const classes: string[] = [];

    if (props.errors && props.errors.length > 0) {
        classes.push("has-error");
    }

    if (props.disabled) {
        classes.push("disabled");
    }

    if (props.changed) {
        classes.push("changed");
    }

    if (isOpen.value) {
        classes.push("open");
    }

    return classes;
});

const selectProps = computed(() => {
    return {
        name: props.name,
        filterable: props.filterable,
        filter: props.filter,
        remote: props.remote,
        placeholder: props.placeholder,
        disabled: props.disabled,
        clearable: props.clearable,
        loading: props.loading,
        "consistent-menu-width": props.menuWidth === "fixed",
        "menu-props": {
            class: "form-select-field"
        },
        "show-checkmark": false,
        "render-label": renderLabel,
        show: props.show,

        // handling of custom value entry
        tag: customValueAllowed.value, // only currently supported for single-value selects
        "fallback-option": (customValueAllowed.value) ? createCustomValueOption : false
    };
});

const dropdownProps = computed(() => {
    return {
        name: props.name,
        "menu-props": () => {
            return {
                class: "form-select-field"
            };
        },
        show: props.show
    };
});

const isLabelVisible = computed(() => props.labelVisible || props.layout === "compact");

const title = computed(() => {
    return (props.label && !isLabelVisible.value) ? props.label : undefined;
});


const optionValues = computed(() => props.options.map(option => option.value));
watch(optionValues, (newValues) => {
    const currentValue = value.value;
    if (currentValue === null || currentValue === undefined) {
        return;
    }

    // clear current value if it is not available in the new options,
    // unless custom value is allowed and the current value is actually a custom value
    if (customValueAllowed.value && currentValue === customValue.value) {
        return;
    }

    if (!newValues.includes(currentValue)) {
        value.value = null;
    }
});

const selectOptions = computed(() => {
    return props.options.map(option => {
        const mappedOption = {
            label: option.label,
            value: option.value,
        } as SelectOption;
        if (option.disabled) {
            mappedOption.disabled = true;
        }
        if (option.icon) {
            mappedOption.icon = option.icon;
        }
        return mappedOption;
    });
});

const dropdownOptions = computed(() => {
    // naive-ui dropdown options use 'key' instead of 'value', so it needs to be mapped
    // currently dropdown has no icon support
    return props.options.map(option => ({
        label: option.label,
        key: option.value,
    }));
});

const handleDropdownSelect = (selectedValue: string) => {
    value.value = selectedValue;
};

const renderLabel = (option: SelectOption) => {
    if (!option.icon) {
        return option.label;
    }
    return [
        renderIcon(option.icon),
        option.label,
    ];
};

const convertIconToObject = (icon: string | OptionIconObject): OptionIconObject => {
    if (typeof icon === "string") {
        return { name: icon };
    }
    return icon;
};

const renderIcon = (icon: string | OptionIconObject) => {
    const iconObject = convertIconToObject(icon);

    return h(
        SvgImage,
        {
            name: iconObject.name,
            class: "option-icon",
            alt: iconObject.alt || undefined
        }
    );
};

const emit = defineEmits<{
    (e: "update:modelValue", value: string | number | null): void,
    (e: "update:customValue", value: string | null): void,
    (e: "search", query: string): void,
    (e: "focus"): void,
    (e: "blur"): void,
    (e: "update:show", show: boolean): void,
    (e: "change"): void,
    (e: "click"): void,
    (e: "clear"): void,
    (e: "keydown", event: KeyboardEvent): void,
}>();

const handleSearch = (query: string) => {
    emit("search", query);
};

const isOpen = ref(false);

watch(() => props.show, (show) => {
    if (show === undefined) {
        return;
    }
    isOpen.value = show;
}, { immediate: true });

const handleUpdateShow = (show: boolean) => {
    isOpen.value = show;
    emit("update:show", show);
};

const handleFocus = () => {
    if (!select.value) {
        return;
    }
    // the "show-on-focus" prop seems to be buggy in naive-ui, so we need to manually focus the input
    // for keyboard navigation with tab key to work.
    // if show-on-focus gets enabled, then for normal non-filterable select fields clicking on the input
    // opens and immediately closes the dropdown.
    select.value.focusInput();
    emit("focus");
};

const handleBlur = () => {
    emit("blur");
};

const handleClick = () => {
    emit("click");
};

const handleClear = () => {
    emit("clear");
};

const handleKeydown = (event: KeyboardEvent) => {
    emit("keydown", event);
};

const focus = () => {
    if (select.value) {
        select.value.focus();
    }
};

const blur = () => {
    if (select.value) {
        select.value.blur();
    }
};

defineExpose({
    focus,
    blur,
    isCustomValue
});


</script>
<style scoped lang="scss">
.field {
    display: block;
    position: relative;
    width: 100%;

    /* stylelint-disable selector-class-pattern */

    &.disabled {
        .label {
            color: $color-text-disabled;
        }

        :deep(.n-select) {

            .n-base-suffix__arrow {
                --n-arrow-color: #{$color-text-disabled};
            }

            .n-base-selection {

                .n-base-selection__border,
                .n-base-selection__state-border {
                    border: 1px solid $color-border-normal;
                }

                .n-base-selection-label {
                    .option-icon {
                        filter: grayscale(100%);
                        opacity: 0.4;
                    }
                }
            }
        }
    }

    &.has-error {
        :deep(.n-select) {
            .n-base-selection {
                .n-base-selection__border,
                .n-base-selection__state-border {

                    border-color: $color-border-error;
                }
            }
        }
    }


    :deep(.n-select) {
        width: 100%;

        .n-base-suffix__arrow {
            --n-arrow-color: #{$color-text-lightest};
            position: relative;
            top: -1px;
        }

        .n-base-selection {
            color: $color-text-normal;

            .n-base-selection__border,
            .n-base-selection__state-border {
                border: 1px solid $color-border-darker;
            }

            .n-base-selection-label {

                .n-base-selection-overlay,
                .n-base-selection-input {
                    padding: 0 steps(3) 0 steps(1);
                }

                .option-icon {
                    // when adjusting these styles, also adjust the same styles in the dropdown menu styles below.
                    // since these are in separate style blocks, they cannot be easily reused.
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    width: steps(1.5);
                    height: steps(1.5);
                    flex-basis: steps(1.5);
                    flex-shrink: 0;
                    margin-right: steps(1);
                }

                .n-base-selection-input {
                    // this is needed for text-overflow ellipsis to work in non-filterable selects.
                    // naiveui adds this for filterable selects, but not for non-filterable ones.
                    position: absolute;
                    inset: 0;
                    display: flex;
                    align-items: center;

                    .n-base-selection-input__content,
                    .n-base-selection-overlay__wrapper {
                        display: flex;
                        align-items: center;
                    }
                }

                .n-base-selection-overlay {
                    .n-base-selection-overlay__wrapper {
                        display: flex;
                        align-items: center;
                    }
                }

                .n-base-selection-placeholder {
                    color: $color-text-lightest;
                }

                .n-base-clear {

                    .n-base-clear__clear {

                        .n-base-icon {
                            position: relative;
                            top: -2px;
                        }
                    }
                }
            }

            .n-base-loading {
                --n-loading-color: #{$color-text-lightest};
            }
        }

    }

    &:not(.disabled) {
        :deep(.n-select) {

            &:hover {
                .n-base-selection {

                    .n-base-selection__border,
                    .n-base-selection__state-border {
                        border-color: $color-border-hover;
                    }

                }
            }
        }
    }

    &.changed {
        :deep(.n-select) {
            .n-base-selection .n-base-selection-label {
                .n-base-selection-input,
                .n-base-selection-placeholder,
                .n-base-selection-label__render-label {
                    color: $color-text-changed;
                }
            }
        }
    }

    .description {
        display: flex;
        align-items: center;
        color: $color-text-lightest;
    }

    &[data-size="medium"] {
        :deep(.n-select) {
            .n-base-suffix__arrow {
                --n-arrow-size: #{steps(2)};
                left: 2px;
            }

            .n-base-selection-label {
                .n-base-selection-overlay,
                .n-base-selection-input {
                    padding-left: 6px;
                    padding-right: steps(3.5);
                }
            }
        }
        .description {
            padding: 0;
            @include small-text;
        }
    }

    &[data-size="large"] {
        :deep(.n-select) {
            .n-base-suffix__arrow {
                --n-arrow-size: #{steps(2.5)};
            }
        }
        .description {
            padding-top: steps(1);
            padding-bottom: steps(1);
            @include normal-text;
        }
    }

    &[data-layout="loose"][data-size="medium"] {
        .label {
            @include small-text;
        }

        :deep(.n-select) {
            .n-base-selection {
                min-height: steps(3);
                @include normal-text;

                .n-base-selection__border,
                .n-base-selection__state-border {
                    border-radius: $element-border-radius-smallest;
                }
            }

            .n-base-selection-label {
                height: steps(3);
            }
        }
    }

    &[data-layout="loose"][data-size="large"] {
        .label {
            @include normal-text;
        }

        :deep(.n-select) {
            .n-base-selection {
                min-height: steps(4.5);
                @include normal-text;

                .n-base-selection__border,
                .n-base-selection__state-border {
                    border-radius: $element-border-radius-small;
                }
            }

            .n-base-selection-label {
                height: steps(4.5);

                .n-base-selection-overlay,
                .n-base-selection-input {
                    padding-left: steps(1);
                    padding-right: steps(3.5);
                }
            }
        }
    }


    &[data-layout="compact"][data-size="medium"] {
        .label {
            @include tiny-medium-text;
            position: absolute;
            z-index: 1; // any positive z-index to put it above the select
            top: 4px;
            left: 6px;
            right: 6px;
            width: auto;
            padding-bottom: 0;
            pointer-events: none;
        }

        :deep(.n-select) {
            .n-base-selection {
                min-height: steps(3.5);
                @include small-medium-text;

                .n-base-selection__border,
                .n-base-selection__state-border {
                    border-radius: $element-border-radius-smaller;
                }
            }

            .n-base-selection-label {
                height: steps(3.5);

                .n-base-selection-input,
                .n-base-selection-overlay {
                    padding-top: 11px;
                }
            }
        }
    }

    &[data-layout="compact"][data-size="large"] {
        .label {
            @include small-text;
            position: absolute;
            z-index: 1; // any positive z-index to put it above the select
            top: 3px;
            left: steps(1);
            right: steps(1);
            width: auto;
            padding-bottom: 0;
            pointer-events: none;
        }

        :deep(.n-select) {
            .n-base-selection {
                min-height: steps(4.5);
                @include normal-text;

                .n-base-selection__border,
                .n-base-selection__state-border {
                    border-radius: $element-border-radius-small;
                }
            }

            .n-base-selection-label {
                height: steps(4.5);

                .n-base-selection-input,
                .n-base-selection-overlay {
                    padding-left: steps(1);
                    padding-top: 14px;
                }
            }
        }
    }

}

/* stylelint-enable selector-class-pattern */
</style>
<style lang="scss">
.n-select-menu.form-select-field,
.n-dropdown-menu.form-select-field {
    border: 1px solid $color-border-normal;

    /* stylelint-disable selector-class-pattern */
    .n-base-select-menu__empty {
        padding: steps(0.5);
        color: $color-text-lightest;
    }

    .n-base-select-menu__action {
        border-top: none;
    }

    .n-base-select-option,
    .n-dropdown-option-body {

        @include normal-text;
        color: $color-text-normal;

        &.n-base-select-option.n-base-select-option--pending::before,
        &.n-dropdown-option-body.n-dropdown-option-body--pending::before {
            background: $color-background-light;
        }

        .n-dropdown-option-body__label {
            align-content: center;
        }

        .n-base-select-option__content,
        .n-base-selection-overlay__wrapper {
            display: flex;
            align-items: center;

            max-width: steps(80);
            // cannot use @include word-clip here because it does not work on flex containers,
            // so no ellipsis for extremely long texts

            .option-icon {
                // when adjusting these styles, also adjust the same styles in the input styles above.
                // since these are in separate style blocks, they cannot be easily reused.
                display: flex;
                align-items: center;
                justify-content: center;
                width: steps(1.5);
                height: steps(1.5);
                flex-basis: steps(1.5);
                flex-shrink: 0;
                margin-right: steps(1);
            }
        }
    }


    /* stylelint-enable selector-class-pattern */

    .no-options.loading {
        .text {
            // in loading state, the blank option box should be shown without the placeholder text
            // but preserve its text-based height, so just make the text invisible instead of removing it
            visibility: hidden;
        }

    }
}
</style>
